import { EMPTY } from './observable/empty';
import { of } from './observable/of';
import { throwError } from './observable/throwError';
export var NotificationKind;
(function (NotificationKind) {
    NotificationKind["NEXT"] = "N";
    NotificationKind["ERROR"] = "E";
    NotificationKind["COMPLETE"] = "C";
})(NotificationKind || (NotificationKind = {}));
let Notification = (() => {
    class Notification {
        constructor(kind, value, error) {
            this.kind = kind;
            this.value = value;
            this.error = error;
            this.hasValue = kind === 'N';
        }
        observe(observer) {
            var _a, _b, _c;
            switch (this.kind) {
                case 'N':
                    (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, this.value);
                    break;
                case 'E':
                    (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, this.error);
                    break;
                case 'C':
                    (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
                    break;
            }
        }
        do(next, error, complete) {
            const kind = this.kind;
            switch (kind) {
                case 'N':
                    next === null || next === void 0 ? void 0 : next(this.value);
                    break;
                case 'E':
                    error === null || error === void 0 ? void 0 : error(this.error);
                    break;
                case 'C':
                    complete === null || complete === void 0 ? void 0 : complete();
                    break;
            }
        }
        accept(nextOrObserver, error, complete) {
            if (nextOrObserver && typeof nextOrObserver.next === 'function') {
                return this.observe(nextOrObserver);
            }
            else {
                return this.do(nextOrObserver, error, complete);
            }
        }
        toObservable() {
            const kind = this.kind;
            switch (kind) {
                case 'N':
                    return of(this.value);
                case 'E':
                    return throwError(this.error);
                case 'C':
                    return EMPTY;
            }
            throw new Error('unexpected notification kind value');
        }
        static createNext(value) {
            return new Notification('N', value);
        }
        static createError(err) {
            return new Notification('E', undefined, err);
        }
        static createComplete() {
            return Notification.completeNotification;
        }
    }
    Notification.completeNotification = new Notification('C');
    return Notification;
})();
export { Notification };
export function observeNotification(notification, observer) {
    var _a, _b, _c;
    if (typeof notification.kind !== 'string') {
        throw new TypeError('Invalid notification, missing "kind"');
    }
    switch (notification.kind) {
        case 'N':
            (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, notification.value);
            break;
        case 'E':
            (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, notification.error);
            break;
        case 'C':
            (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
            break;
    }
}
export const COMPLETE_NOTIFICATION = (() => createNotification('C', undefined, undefined))();
export function errorNotification(error) {
    return createNotification('E', undefined, error);
}
export function nextNotification(value) {
    return createNotification('N', value, undefined);
}
export function createNotification(kind, value, error) {
    return {
        kind,
        value,
        error,
    };
}
//# sourceMappingURL=Notification.js.map